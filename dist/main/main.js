/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/main/main.ts":
/*!**************************!*\
  !*** ./src/main/main.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! electron */ \"electron\");\n/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _shared_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/types */ \"./src/shared/types.ts\");\n/* harmony import */ var _services_KeyboardService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./services/KeyboardService */ \"./src/main/services/KeyboardService.ts\");\n/* harmony import */ var _services_database_DataManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./services/database/DataManager */ \"./src/main/services/database/DataManager.ts\");\n/* harmony import */ var _windows_WindowManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./windows/WindowManager */ \"./src/main/windows/WindowManager.ts\");\n\n\n\n\n\nclass ElectronApp {\n    constructor() {\n        this.mainWindow = null;\n        this.keyboardService = null;\n        this.isDev = \"development\" === 'development';\n        this.initializeApp();\n        this.initializeKeyboardService();\n    }\n    initializeApp() {\n        // Handle app ready event\n        electron__WEBPACK_IMPORTED_MODULE_0__.app.whenReady().then(() => {\n            this.createMainWindow();\n            this.setupIPC();\n            // macOS specific: recreate window when dock icon is clicked\n            electron__WEBPACK_IMPORTED_MODULE_0__.app.on('activate', () => {\n                if (electron__WEBPACK_IMPORTED_MODULE_0__.BrowserWindow.getAllWindows().length === 0) {\n                    this.createMainWindow();\n                }\n            });\n        });\n        // Quit when all windows are closed (except on macOS)\n        electron__WEBPACK_IMPORTED_MODULE_0__.app.on('window-all-closed', () => {\n            if (process.platform !== 'darwin') {\n                electron__WEBPACK_IMPORTED_MODULE_0__.app.quit();\n            }\n        });\n        // Security: Prevent new window creation\n        electron__WEBPACK_IMPORTED_MODULE_0__.app.on('web-contents-created', (_, contents) => {\n            contents.setWindowOpenHandler(() => {\n                return { action: 'deny' };\n            });\n        });\n        // 앱 종료 시 서비스 정리\n        electron__WEBPACK_IMPORTED_MODULE_0__.app.on('before-quit', async () => {\n            if (this.keyboardService) {\n                this.keyboardService.destroy();\n            }\n            // 윈도우 관리자 정리\n            _windows_WindowManager__WEBPACK_IMPORTED_MODULE_4__.windowManager.destroy();\n            // 데이터 관리자 종료\n            try {\n                await _services_database_DataManager__WEBPACK_IMPORTED_MODULE_3__.dataManager.shutdown();\n            }\n            catch (error) {\n                console.error('Failed to shutdown DataManager:', error);\n            }\n        });\n    }\n    createMainWindow() {\n        // WindowManager를 사용하여 메인 창 생성\n        this.mainWindow = _windows_WindowManager__WEBPACK_IMPORTED_MODULE_4__.windowManager.createMainWindow();\n        // 위젯 창도 함께 생성\n        this.createWidgetWindow();\n    }\n    async createWidgetWindow() {\n        try {\n            await _windows_WindowManager__WEBPACK_IMPORTED_MODULE_4__.windowManager.createWidgetWindow();\n            console.log('Widget window created successfully');\n        }\n        catch (error) {\n            console.error('Failed to create widget window:', error);\n        }\n    }\n    initializeKeyboardService() {\n        this.keyboardService = new _services_KeyboardService__WEBPACK_IMPORTED_MODULE_2__.KeyboardService();\n        // 타이핑 이벤트 리스너 (send 사용 - 단방향)\n        this.keyboardService.on('typing', (metadata) => {\n            const typingEvent = {\n                timestamp: metadata.timestamp,\n                keyCount: metadata.keyCount,\n                interval: metadata.interval,\n                isActive: metadata.isActive,\n                sessionId: metadata.sessionId\n            };\n            console.log('Typing detected:', {\n                keyCount: typingEvent.keyCount,\n                interval: typingEvent.interval,\n                sessionId: typingEvent.sessionId\n            });\n            // 메인 창과 위젯 창 모두에 타이핑 이벤트 전송\n            if (this.mainWindow) {\n                this.mainWindow.webContents.send(_shared_types__WEBPACK_IMPORTED_MODULE_1__.IPCChannels.TYPING_EVENT, typingEvent);\n            }\n            // 위젯 창에도 타이핑 이벤트 전송\n            const widgetWindow = _windows_WindowManager__WEBPACK_IMPORTED_MODULE_4__.windowManager.getWidgetWindow();\n            if (widgetWindow && !widgetWindow.isDestroyed()) {\n                widgetWindow.webContents.send(_shared_types__WEBPACK_IMPORTED_MODULE_1__.IPCChannels.TYPING_EVENT, typingEvent);\n            }\n        });\n        // 타이핑 세션 종료 이벤트 (send 사용)\n        this.keyboardService.on('typingEnd', (metadata) => {\n            const typingEvent = {\n                timestamp: metadata.timestamp,\n                keyCount: metadata.keyCount,\n                interval: metadata.interval,\n                isActive: false,\n                sessionId: metadata.sessionId\n            };\n            console.log('Typing session ended:', typingEvent.sessionId);\n            if (this.mainWindow) {\n                this.mainWindow.webContents.send(_shared_types__WEBPACK_IMPORTED_MODULE_1__.IPCChannels.TYPING_SESSION_END, typingEvent);\n            }\n            // 위젯 창에도 세션 종료 이벤트 전송\n            const widgetWindow = _windows_WindowManager__WEBPACK_IMPORTED_MODULE_4__.windowManager.getWidgetWindow();\n            if (widgetWindow && !widgetWindow.isDestroyed()) {\n                widgetWindow.webContents.send(_shared_types__WEBPACK_IMPORTED_MODULE_1__.IPCChannels.TYPING_SESSION_END, typingEvent);\n            }\n        });\n        // 권한 요청 처리\n        this.keyboardService.on('permissionRequired', (permissionInfo) => {\n            console.log('Permission required:', permissionInfo);\n            // 시스템 다이얼로그로 권한 요청 안내\n            this.showPermissionDialog(permissionInfo);\n            // 렌더러로 권한 요청 정보 전송\n            if (this.mainWindow) {\n                this.mainWindow.webContents.send('permission:required', permissionInfo);\n            }\n        });\n        // 서비스 에러 처리\n        this.keyboardService.on('serviceError', (error) => {\n            console.error('Keyboard service error:', error);\n        });\n    }\n    setupIPC() {\n        // Test IPC communication\n        electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.handle(_shared_types__WEBPACK_IMPORTED_MODULE_1__.IPCChannels.PING, async () => {\n            console.log('Main process received ping');\n            return 'pong';\n        });\n        // 키보드 서비스 제어 (invoke 사용 - 결과 필요)\n        electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.handle('keyboard:start', async () => {\n            try {\n                this.keyboardService?.startListening();\n                return { success: true, message: 'Keyboard service started' };\n            }\n            catch (error) {\n                return { success: false, error: error.message };\n            }\n        });\n        electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.handle('keyboard:stop', async () => {\n            try {\n                this.keyboardService?.stopListening();\n                return { success: true, message: 'Keyboard service stopped' };\n            }\n            catch (error) {\n                return { success: false, error: error.message };\n            }\n        });\n        electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.handle('keyboard:status', async () => {\n            return {\n                isActive: this.keyboardService?.isActive() || false,\n                keyCount: this.keyboardService?.getKeyCount() || 0,\n                sessionId: this.keyboardService?.getCurrentSession() || null\n            };\n        });\n        // Handle dashboard open request\n        electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.on(_shared_types__WEBPACK_IMPORTED_MODULE_1__.IPCChannels.DASHBOARD_OPEN, () => {\n            console.log('Dashboard open requested');\n            // TODO: Implement dashboard window creation\n        });\n        // Handle dashboard close request\n        electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.on(_shared_types__WEBPACK_IMPORTED_MODULE_1__.IPCChannels.DASHBOARD_CLOSE, () => {\n            console.log('Dashboard close requested');\n            // TODO: Implement dashboard window closing\n        });\n        // Handle typing events (will be implemented in future tasks)\n        electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.on(_shared_types__WEBPACK_IMPORTED_MODULE_1__.IPCChannels.TYPING_EVENT, (_, event) => {\n            console.log('Typing event received:', event);\n            // TODO: Process typing event and trigger Hammy reaction\n        });\n        // 데이터베이스 관련 IPC 핸들러\n        electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.handle('database:getStats', async (_, period = 'today') => {\n            try {\n                const stats = await _services_database_DataManager__WEBPACK_IMPORTED_MODULE_3__.dataManager.getStats(period);\n                return { success: true, data: stats };\n            }\n            catch (error) {\n                return { success: false, error: error.message };\n            }\n        });\n        electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.handle('database:getRecentSessions', async (_, limit = 10) => {\n            try {\n                const sessions = await _services_database_DataManager__WEBPACK_IMPORTED_MODULE_3__.dataManager.getRecentSessions(limit);\n                return { success: true, data: sessions };\n            }\n            catch (error) {\n                return { success: false, error: error.message };\n            }\n        });\n        electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.handle('database:getSetting', async (_, key) => {\n            try {\n                const value = await _services_database_DataManager__WEBPACK_IMPORTED_MODULE_3__.dataManager.getSetting(key);\n                return { success: true, data: value };\n            }\n            catch (error) {\n                return { success: false, error: error.message };\n            }\n        });\n        electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.handle('database:setSetting', async (_, key, value) => {\n            try {\n                await _services_database_DataManager__WEBPACK_IMPORTED_MODULE_3__.dataManager.setSetting(key, value);\n                return { success: true };\n            }\n            catch (error) {\n                return { success: false, error: error.message };\n            }\n        });\n        electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.handle('database:getAllSettings', async () => {\n            try {\n                const settings = await _services_database_DataManager__WEBPACK_IMPORTED_MODULE_3__.dataManager.getAllSettings();\n                return { success: true, data: settings };\n            }\n            catch (error) {\n                return { success: false, error: error.message };\n            }\n        });\n        electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.handle('database:getStatus', async () => {\n            try {\n                const status = await _services_database_DataManager__WEBPACK_IMPORTED_MODULE_3__.dataManager.getStatus();\n                return { success: true, data: status };\n            }\n            catch (error) {\n                return { success: false, error: error.message };\n            }\n        });\n        electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.handle('database:cleanupOldData', async () => {\n            try {\n                await _services_database_DataManager__WEBPACK_IMPORTED_MODULE_3__.dataManager.cleanupOldData();\n                return { success: true };\n            }\n            catch (error) {\n                return { success: false, error: error.message };\n            }\n        });\n        // 위젯 관련 IPC 핸들러\n        electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.handle('widget:show', async () => {\n            try {\n                _windows_WindowManager__WEBPACK_IMPORTED_MODULE_4__.windowManager.showWidget();\n                return { success: true };\n            }\n            catch (error) {\n                return { success: false, error: error.message };\n            }\n        });\n        electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.handle('widget:hide', async () => {\n            try {\n                _windows_WindowManager__WEBPACK_IMPORTED_MODULE_4__.windowManager.hideWidget();\n                return { success: true };\n            }\n            catch (error) {\n                return { success: false, error: error.message };\n            }\n        });\n        electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.handle('widget:toggle', async () => {\n            try {\n                _windows_WindowManager__WEBPACK_IMPORTED_MODULE_4__.windowManager.toggleWidget();\n                return { success: true, visible: _windows_WindowManager__WEBPACK_IMPORTED_MODULE_4__.windowManager.isWidgetVisible() };\n            }\n            catch (error) {\n                return { success: false, error: error.message };\n            }\n        });\n        electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.handle('widget:setPosition', async (_, x, y) => {\n            try {\n                _windows_WindowManager__WEBPACK_IMPORTED_MODULE_4__.windowManager.setWidgetPosition(x, y);\n                return { success: true };\n            }\n            catch (error) {\n                return { success: false, error: error.message };\n            }\n        });\n        electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.handle('widget:getPosition', async () => {\n            try {\n                const position = _windows_WindowManager__WEBPACK_IMPORTED_MODULE_4__.windowManager.getWidgetPosition();\n                return { success: true, data: position };\n            }\n            catch (error) {\n                return { success: false, error: error.message };\n            }\n        });\n        electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.handle('widget:savePosition', async (_, x, y) => {\n            try {\n                await _services_database_DataManager__WEBPACK_IMPORTED_MODULE_3__.dataManager.setSetting('widget_position_x', x);\n                await _services_database_DataManager__WEBPACK_IMPORTED_MODULE_3__.dataManager.setSetting('widget_position_y', y);\n                return { success: true };\n            }\n            catch (error) {\n                return { success: false, error: error.message };\n            }\n        });\n        electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.handle('widget:getStatus', async () => {\n            try {\n                return {\n                    success: true,\n                    data: {\n                        isOpen: _windows_WindowManager__WEBPACK_IMPORTED_MODULE_4__.windowManager.isWidgetWindowOpen(),\n                        isVisible: _windows_WindowManager__WEBPACK_IMPORTED_MODULE_4__.windowManager.isWidgetVisible(),\n                        position: _windows_WindowManager__WEBPACK_IMPORTED_MODULE_4__.windowManager.getWidgetPosition()\n                    }\n                };\n            }\n            catch (error) {\n                return { success: false, error: error.message };\n            }\n        });\n    }\n    async showPermissionDialog(permissionInfo) {\n        if (!this.mainWindow)\n            return;\n        const result = await electron__WEBPACK_IMPORTED_MODULE_0__.dialog.showMessageBox(this.mainWindow, {\n            type: 'warning',\n            title: '키보드 접근 권한 필요',\n            message: 'Typster Hammy가 키보드 이벤트를 감지하려면 접근성 권한이 필요합니다.',\n            detail: `macOS 시스템 환경설정에서 접근성 권한을 부여해주세요:\n\n1. 시스템 환경설정을 엽니다\n2. 보안 및 개인 정보 보호를 클릭합니다\n3. 개인 정보 보호 탭을 선택합니다\n4. 접근성을 클릭합니다\n5. 자물쇠를 클릭하여 변경을 허용합니다\n6. + 버튼을 클릭하여 앱을 추가합니다\n7. Electron 또는 Typster Hammy를 찾아 추가합니다\n8. 체크박스를 활성화합니다\n\n권한을 부여한 후 앱을 다시 시작해주세요.`,\n            buttons: ['시스템 환경설정 열기', '나중에', '개발 모드로 계속'],\n            defaultId: 0,\n            cancelId: 1\n        });\n        switch (result.response) {\n            case 0: // 시스템 환경설정 열기\n                try {\n                    // macOS 시스템 환경설정의 접근성 페이지 직접 열기\n                    await electron__WEBPACK_IMPORTED_MODULE_0__.shell.openExternal('x-apple.systempreferences:com.apple.preference.security?Privacy_Accessibility');\n                }\n                catch (error) {\n                    console.error('Failed to open system preferences:', error);\n                    // 백업: 일반 시스템 환경설정 열기\n                    await electron__WEBPACK_IMPORTED_MODULE_0__.shell.openExternal('x-apple.systempreferences:com.apple.preference.security');\n                }\n                break;\n            case 1: // 나중에\n                console.log('User chose to set permissions later');\n                break;\n            case 2: // 개발 모드로 계속\n                console.log('User chose to continue in development mode');\n                // 시뮬레이션 모드는 이미 KeyboardService에서 처리됨\n                break;\n        }\n    }\n    getMainWindow() {\n        return this.mainWindow;\n    }\n}\n// Initialize the application\nnew ElectronApp();\n\n\n//# sourceURL=webpack://typster-hammy/./src/main/main.ts?\n}");

/***/ }),

/***/ "./src/main/services/KeyboardService.ts":
/*!**********************************************!*\
  !*** ./src/main/services/KeyboardService.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   KeyboardService: () => (/* binding */ KeyboardService)\n/* harmony export */ });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _native__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./native */ \"./src/main/services/native/index.ts\");\n/* harmony import */ var _database_DataManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./database/DataManager */ \"./src/main/services/database/DataManager.ts\");\n\n\n\nclass KeyboardService extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    constructor() {\n        super();\n        this.lastKeyTime = 0;\n        this.keyCount = 0;\n        this.isListening = false;\n        this.typingTimeout = null;\n        this.TYPING_TIMEOUT = 2000; // 2초 후 타이핑 세션 종료\n        this.simulationInterval = null;\n        this.isSimulationMode = false;\n        this.nativeListener = new _native__WEBPACK_IMPORTED_MODULE_1__.NativeKeyboardListener();\n        this.sessionId = this.generateSessionId();\n    }\n    generateSessionId() {\n        return `session_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;\n    }\n    handleNativeKeyEvent(event) {\n        // 키를 누를 때만 처리 (키를 뗄 때는 무시)\n        if (!event.isKeyDown)\n            return;\n        // 특수 키는 무시 (프라이버시 보호)\n        if (event.isSpecialKey)\n            return;\n        this.handleKeyPress(event.timestamp);\n    }\n    handleKeyPress(timestamp) {\n        const currentTime = timestamp || Date.now();\n        const interval = this.lastKeyTime > 0 ? currentTime - this.lastKeyTime : 0;\n        this.keyCount++;\n        this.lastKeyTime = currentTime;\n        // 타이핑 세션 타임아웃 리셋\n        if (this.typingTimeout) {\n            clearTimeout(this.typingTimeout);\n        }\n        // 메타데이터 생성 (키 내용은 포함하지 않음 - 프라이버시 보호)\n        const metadata = {\n            timestamp: currentTime,\n            keyCount: this.keyCount,\n            interval,\n            isActive: true,\n            sessionId: this.sessionId\n        };\n        // 데이터베이스에 타이핑 이벤트 저장\n        _database_DataManager__WEBPACK_IMPORTED_MODULE_2__.dataManager.handleTypingEvent(metadata).catch(error => {\n            console.error('Failed to save typing event to database:', error);\n        });\n        // 타이핑 이벤트 발생\n        this.emit('typing', metadata);\n        // 타이핑 세션 종료 타이머 설정\n        this.typingTimeout = setTimeout(() => {\n            this.endTypingSession();\n        }, this.TYPING_TIMEOUT);\n    }\n    endTypingSession() {\n        const endMetadata = {\n            timestamp: Date.now(),\n            keyCount: this.keyCount,\n            interval: 0,\n            isActive: false,\n            sessionId: this.sessionId\n        };\n        // 데이터베이스에 세션 종료 저장\n        _database_DataManager__WEBPACK_IMPORTED_MODULE_2__.dataManager.handleSessionEnd(endMetadata).catch(error => {\n            console.error('Failed to save session end to database:', error);\n        });\n        this.emit('typingEnd', endMetadata);\n        // 새로운 세션 시작 준비\n        this.keyCount = 0;\n        this.lastKeyTime = 0;\n        this.sessionId = this.generateSessionId();\n    }\n    startListening() {\n        if (this.isListening)\n            return;\n        try {\n            // 권한 확인\n            const permissions = this.nativeListener.checkPermissions();\n            if (!permissions.hasPermission) {\n                console.warn('Keyboard permissions not granted:');\n                console.warn(permissions.permissionMessage);\n                // 더 자세한 권한 안내 메시지\n                const detailedMessage = process.platform === 'darwin'\n                    ? 'macOS 접근성 권한이 필요합니다.\\n\\n1. 시스템 환경설정을 엽니다\\n2. 보안 및 개인 정보 보호를 클릭합니다\\n3. 개인 정보 보호 탭을 선택합니다\\n4. 접근성을 클릭합니다\\n5. Electron 또는 Typster Hammy 앱을 체크합니다\\n\\n권한을 부여한 후 앱을 다시 시작해주세요.'\n                    : permissions.permissionMessage;\n                this.emit('permissionRequired', {\n                    platform: process.platform,\n                    message: detailedMessage,\n                    requiresElevation: permissions.requiresElevation\n                });\n                // 개발 중에는 권한 없이도 계속 진행 (시뮬레이션 모드)\n                console.log('개발 모드: 권한 없이 시뮬레이션 모드로 진행합니다.');\n                this.startSimulationMode();\n                return;\n            }\n            // 네이티브 키보드 리스너 시작\n            const success = this.nativeListener.startListening((event) => {\n                this.handleNativeKeyEvent(event);\n            });\n            if (!success) {\n                throw new Error('Failed to start native keyboard listener');\n            }\n            this.isListening = true;\n            console.log('Native keyboard service started successfully');\n            this.emit('serviceStarted');\n        }\n        catch (error) {\n            console.error('Failed to start keyboard service:', error);\n            this.emit('serviceError', error);\n            throw error;\n        }\n    }\n    stopListening() {\n        if (!this.isListening)\n            return;\n        try {\n            // 타이핑 타임아웃 정리\n            if (this.typingTimeout) {\n                clearTimeout(this.typingTimeout);\n                this.typingTimeout = null;\n            }\n            // 시뮬레이션 모드인 경우\n            if (this.isSimulationMode) {\n                this.stopSimulationMode();\n            }\n            else {\n                // 네이티브 리스너 중지\n                this.nativeListener.stopListening();\n            }\n            this.isListening = false;\n            console.log('Keyboard service stopped');\n            this.emit('serviceStopped');\n        }\n        catch (error) {\n            console.error('Failed to stop keyboard service:', error);\n            this.emit('serviceError', error);\n        }\n    }\n    isActive() {\n        return this.isListening && (this.isSimulationMode || this.nativeListener.isListening());\n    }\n    getCurrentSession() {\n        return this.sessionId;\n    }\n    getKeyCount() {\n        return this.keyCount;\n    }\n    checkPermissions() {\n        return this.nativeListener.checkPermissions();\n    }\n    startSimulationMode() {\n        this.isSimulationMode = true;\n        this.isListening = true;\n        console.log('시뮬레이션 모드 시작: 가짜 타이핑 이벤트를 생성합니다.');\n        // 3초마다 랜덤한 타이핑 이벤트 생성\n        this.simulationInterval = setInterval(() => {\n            // 랜덤한 간격으로 타이핑 이벤트 생성 (100ms ~ 500ms)\n            const interval = Math.random() * 400 + 100;\n            setTimeout(() => {\n                this.handleKeyPress();\n            }, interval);\n            // 가끔 연속 타이핑 시뮬레이션 (30% 확률)\n            if (Math.random() < 0.3) {\n                setTimeout(() => {\n                    this.handleKeyPress();\n                }, interval + 150);\n                setTimeout(() => {\n                    this.handleKeyPress();\n                }, interval + 300);\n            }\n        }, 3000);\n        this.emit('serviceStarted');\n    }\n    stopSimulationMode() {\n        if (this.simulationInterval) {\n            clearInterval(this.simulationInterval);\n            this.simulationInterval = null;\n        }\n        this.isSimulationMode = false;\n        console.log('시뮬레이션 모드 중지');\n    }\n    destroy() {\n        this.stopListening();\n        this.stopSimulationMode();\n        this.removeAllListeners();\n    }\n}\n\n\n//# sourceURL=webpack://typster-hammy/./src/main/services/KeyboardService.ts?\n}");

/***/ }),

/***/ "./src/main/services/database/DataManager.ts":
/*!***************************************************!*\
  !*** ./src/main/services/database/DataManager.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DataManager: () => (/* binding */ DataManager),\n/* harmony export */   dataManager: () => (/* binding */ dataManager)\n/* harmony export */ });\n/* harmony import */ var _DatabaseService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DatabaseService */ \"./src/main/services/database/DatabaseService.ts\");\n/* harmony import */ var _models_TypingSession__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./models/TypingSession */ \"./src/main/services/database/models/TypingSession.ts\");\n/* harmony import */ var _models_TypingEvent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./models/TypingEvent */ \"./src/main/services/database/models/TypingEvent.ts\");\n/* harmony import */ var _models_DailyStats__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./models/DailyStats */ \"./src/main/services/database/models/DailyStats.ts\");\n/* harmony import */ var _models_AppSettings__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./models/AppSettings */ \"./src/main/services/database/models/AppSettings.ts\");\n\n\n\n\n\n/**\n * 데이터 관리자 - 키보드 서비스와 데이터베이스 간의 중간 계층\n */\nclass DataManager {\n    constructor() {\n        this.currentSessionId = null;\n        this.sessionStartTime = 0;\n        this.sessionKeyCount = 0;\n        this.sessionIntervals = [];\n        this.initialize();\n    }\n    /**\n     * 데이터 관리자 초기화\n     */\n    async initialize() {\n        try {\n            await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.initialize();\n            console.log('DataManager initialized successfully');\n            // 앱 시작 시 오늘 통계 업데이트\n            await this.updateTodayStats();\n        }\n        catch (error) {\n            console.error('Failed to initialize DataManager:', error);\n            throw error;\n        }\n    }\n    /**\n     * 타이핑 이벤트 처리 (KeyboardService에서 호출)\n     */\n    async handleTypingEvent(metadata) {\n        try {\n            // 새로운 세션 시작\n            if (metadata.sessionId !== this.currentSessionId) {\n                await this.startNewSession(metadata);\n            }\n            // 타이핑 이벤트 저장\n            await _models_TypingEvent__WEBPACK_IMPORTED_MODULE_2__.TypingEvent.create({\n                session_id: metadata.sessionId,\n                timestamp: metadata.timestamp,\n                key_count: metadata.keyCount,\n                interval_ms: metadata.interval,\n                is_active: metadata.isActive\n            });\n            // 세션 정보 업데이트\n            this.sessionKeyCount = metadata.keyCount;\n            if (metadata.interval > 0) {\n                this.sessionIntervals.push(metadata.interval);\n            }\n            // 진행 중인 세션 업데이트\n            await this.updateCurrentSession(metadata);\n            console.log(`Typing event saved: Session ${metadata.sessionId}, Key ${metadata.keyCount}`);\n        }\n        catch (error) {\n            console.error('Failed to handle typing event:', error);\n        }\n    }\n    /**\n     * 타이핑 세션 종료 처리\n     */\n    async handleSessionEnd(metadata) {\n        if (!this.currentSessionId || this.currentSessionId !== metadata.sessionId) {\n            return;\n        }\n        try {\n            const endTime = metadata.timestamp;\n            const duration = endTime - this.sessionStartTime;\n            const averageInterval = this.sessionIntervals.length > 0\n                ? this.sessionIntervals.reduce((sum, interval) => sum + interval, 0) / this.sessionIntervals.length\n                : 0;\n            // 세션 종료 처리\n            await _models_TypingSession__WEBPACK_IMPORTED_MODULE_1__.TypingSession.endSession(metadata.sessionId, endTime, this.sessionKeyCount, duration, averageInterval);\n            console.log(`Session ended: ${metadata.sessionId}, Duration: ${duration}ms, Keys: ${this.sessionKeyCount}`);\n            // 세션 정보 초기화\n            this.resetSessionData();\n            // 오늘 통계 업데이트\n            await this.updateTodayStats();\n        }\n        catch (error) {\n            console.error('Failed to handle session end:', error);\n        }\n    }\n    /**\n     * 새로운 세션 시작\n     */\n    async startNewSession(metadata) {\n        // 이전 세션이 있다면 강제 종료\n        if (this.currentSessionId) {\n            await this.forceEndCurrentSession();\n        }\n        // 새 세션 생성\n        await _models_TypingSession__WEBPACK_IMPORTED_MODULE_1__.TypingSession.create({\n            session_id: metadata.sessionId,\n            start_time: metadata.timestamp,\n            total_keys: 0,\n            duration: 0,\n            average_interval: 0\n        });\n        // 세션 정보 설정\n        this.currentSessionId = metadata.sessionId;\n        this.sessionStartTime = metadata.timestamp;\n        this.sessionKeyCount = 0;\n        this.sessionIntervals = [];\n        console.log(`New session started: ${metadata.sessionId}`);\n    }\n    /**\n     * 현재 세션 업데이트\n     */\n    async updateCurrentSession(metadata) {\n        if (!this.currentSessionId)\n            return;\n        const averageInterval = this.sessionIntervals.length > 0\n            ? this.sessionIntervals.reduce((sum, interval) => sum + interval, 0) / this.sessionIntervals.length\n            : 0;\n        await _models_TypingSession__WEBPACK_IMPORTED_MODULE_1__.TypingSession.updateKeyCount(this.currentSessionId, this.sessionKeyCount, averageInterval);\n    }\n    /**\n     * 현재 세션 강제 종료\n     */\n    async forceEndCurrentSession() {\n        if (!this.currentSessionId)\n            return;\n        const endTime = Date.now();\n        const duration = endTime - this.sessionStartTime;\n        const averageInterval = this.sessionIntervals.length > 0\n            ? this.sessionIntervals.reduce((sum, interval) => sum + interval, 0) / this.sessionIntervals.length\n            : 0;\n        await _models_TypingSession__WEBPACK_IMPORTED_MODULE_1__.TypingSession.endSession(this.currentSessionId, endTime, this.sessionKeyCount, duration, averageInterval);\n        console.log(`Force ended session: ${this.currentSessionId}`);\n    }\n    /**\n     * 세션 데이터 초기화\n     */\n    resetSessionData() {\n        this.currentSessionId = null;\n        this.sessionStartTime = 0;\n        this.sessionKeyCount = 0;\n        this.sessionIntervals = [];\n    }\n    /**\n     * 오늘 통계 업데이트\n     */\n    async updateTodayStats() {\n        try {\n            await _models_DailyStats__WEBPACK_IMPORTED_MODULE_3__.DailyStats.updateTodayStats();\n        }\n        catch (error) {\n            console.error('Failed to update today stats:', error);\n        }\n    }\n    /**\n     * 통계 데이터 조회\n     */\n    async getStats(period = 'today') {\n        try {\n            const today = new Date().toISOString().split('T')[0];\n            switch (period) {\n                case 'today':\n                    return await _models_DailyStats__WEBPACK_IMPORTED_MODULE_3__.DailyStats.findByDate(today);\n                case 'week':\n                    const weekStart = new Date();\n                    weekStart.setDate(weekStart.getDate() - 6);\n                    const weekStartStr = weekStart.toISOString().split('T')[0];\n                    return await _models_DailyStats__WEBPACK_IMPORTED_MODULE_3__.DailyStats.getWeeklyStats(weekStartStr);\n                case 'month':\n                    const now = new Date();\n                    return await _models_DailyStats__WEBPACK_IMPORTED_MODULE_3__.DailyStats.getMonthlyStats(now.getFullYear(), now.getMonth() + 1);\n                default:\n                    return null;\n            }\n        }\n        catch (error) {\n            console.error('Failed to get stats:', error);\n            return null;\n        }\n    }\n    /**\n     * 최근 세션 조회\n     */\n    async getRecentSessions(limit = 10) {\n        try {\n            return await _models_TypingSession__WEBPACK_IMPORTED_MODULE_1__.TypingSession.findRecent(limit);\n        }\n        catch (error) {\n            console.error('Failed to get recent sessions:', error);\n            return [];\n        }\n    }\n    /**\n     * 설정 관리\n     */\n    async getSetting(key) {\n        try {\n            return await _models_AppSettings__WEBPACK_IMPORTED_MODULE_4__.AppSettings.get(key);\n        }\n        catch (error) {\n            console.error(`Failed to get setting ${key}:`, error);\n            return null;\n        }\n    }\n    async setSetting(key, value) {\n        try {\n            await _models_AppSettings__WEBPACK_IMPORTED_MODULE_4__.AppSettings.set(key, value);\n        }\n        catch (error) {\n            console.error(`Failed to set setting ${key}:`, error);\n        }\n    }\n    async getAllSettings() {\n        try {\n            return await _models_AppSettings__WEBPACK_IMPORTED_MODULE_4__.AppSettings.getAll();\n        }\n        catch (error) {\n            console.error('Failed to get all settings:', error);\n            return {};\n        }\n    }\n    /**\n     * 데이터 정리 (오래된 데이터 삭제)\n     */\n    async cleanupOldData() {\n        try {\n            const retentionDays = await _models_AppSettings__WEBPACK_IMPORTED_MODULE_4__.AppSettings.getNumber('data_retention_days', 365);\n            const deletedSessions = await _models_TypingSession__WEBPACK_IMPORTED_MODULE_1__.TypingSession.deleteOldSessions(retentionDays);\n            const deletedEvents = await _models_TypingEvent__WEBPACK_IMPORTED_MODULE_2__.TypingEvent.deleteOldEvents(retentionDays);\n            const deletedStats = await _models_DailyStats__WEBPACK_IMPORTED_MODULE_3__.DailyStats.deleteOldStats(retentionDays);\n            console.log(`Data cleanup completed: ${deletedSessions} sessions, ${deletedEvents} events, ${deletedStats} stats deleted`);\n        }\n        catch (error) {\n            console.error('Failed to cleanup old data:', error);\n        }\n    }\n    /**\n     * 데이터베이스 상태 확인\n     */\n    async getStatus() {\n        try {\n            const isConnected = _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.isConnected();\n            const dbPath = _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.getDatabasePath();\n            if (!isConnected) {\n                return {\n                    isConnected: false,\n                    dbPath,\n                    totalSessions: 0,\n                    totalEvents: 0,\n                    totalStats: 0\n                };\n            }\n            const totalSessions = await _models_TypingSession__WEBPACK_IMPORTED_MODULE_1__.TypingSession.getTotalCount();\n            const totalEvents = await _models_TypingEvent__WEBPACK_IMPORTED_MODULE_2__.TypingEvent.getTotalCount();\n            const totalStats = await _models_DailyStats__WEBPACK_IMPORTED_MODULE_3__.DailyStats.getTotalCount();\n            return {\n                isConnected,\n                dbPath,\n                totalSessions,\n                totalEvents,\n                totalStats\n            };\n        }\n        catch (error) {\n            console.error('Failed to get database status:', error);\n            return {\n                isConnected: false,\n                dbPath: '',\n                totalSessions: 0,\n                totalEvents: 0,\n                totalStats: 0\n            };\n        }\n    }\n    /**\n     * 데이터 관리자 종료\n     */\n    async shutdown() {\n        try {\n            // 현재 세션이 있다면 종료\n            if (this.currentSessionId) {\n                await this.forceEndCurrentSession();\n            }\n            // 데이터베이스 연결 종료\n            await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.close();\n            console.log('DataManager shutdown completed');\n        }\n        catch (error) {\n            console.error('Failed to shutdown DataManager:', error);\n        }\n    }\n}\n// 싱글톤 인스턴스\nconst dataManager = new DataManager();\n\n\n//# sourceURL=webpack://typster-hammy/./src/main/services/database/DataManager.ts?\n}");

/***/ }),

/***/ "./src/main/services/database/DatabaseService.ts":
/*!*******************************************************!*\
  !*** ./src/main/services/database/DatabaseService.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DatabaseService: () => (/* binding */ DatabaseService),\n/* harmony export */   databaseService: () => (/* binding */ databaseService)\n/* harmony export */ });\n/* harmony import */ var sqlite3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sqlite3 */ \"sqlite3\");\n/* harmony import */ var sqlite3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(sqlite3__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! electron */ \"electron\");\n/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\nclass DatabaseService {\n    constructor(config = {}) {\n        this.db = null;\n        this.isInitialized = false;\n        // 데이터베이스 파일 경로 설정 (사용자 데이터 디렉토리)\n        const userDataPath = electron__WEBPACK_IMPORTED_MODULE_3__.app.getPath('userData');\n        this.dbPath = config.dbPath || path__WEBPACK_IMPORTED_MODULE_1__.join(userDataPath, 'typster-hammy.db');\n        // 디렉토리가 없으면 생성\n        const dbDir = path__WEBPACK_IMPORTED_MODULE_1__.dirname(this.dbPath);\n        if (!fs__WEBPACK_IMPORTED_MODULE_2__.existsSync(dbDir)) {\n            fs__WEBPACK_IMPORTED_MODULE_2__.mkdirSync(dbDir, { recursive: true });\n        }\n    }\n    /**\n     * 데이터베이스 연결 및 초기화\n     */\n    async initialize() {\n        if (this.isInitialized) {\n            return;\n        }\n        return new Promise((resolve, reject) => {\n            this.db = new sqlite3__WEBPACK_IMPORTED_MODULE_0__.Database(this.dbPath, (err) => {\n                if (err) {\n                    console.error('Database connection failed:', err);\n                    reject(err);\n                    return;\n                }\n                console.log(`Connected to SQLite database: ${this.dbPath}`);\n                this.setupDatabase()\n                    .then(() => {\n                    this.isInitialized = true;\n                    resolve();\n                })\n                    .catch(reject);\n            });\n        });\n    }\n    /**\n     * 데이터베이스 설정 및 스키마 생성\n     */\n    async setupDatabase() {\n        if (!this.db) {\n            throw new Error('Database not connected');\n        }\n        // WAL 모드 활성화 (성능 향상)\n        await this.run('PRAGMA journal_mode = WAL');\n        // 외래 키 제약 조건 활성화\n        await this.run('PRAGMA foreign_keys = ON');\n        // 스키마 생성\n        await this.createTables();\n        // 인덱스 생성\n        await this.createIndexes();\n        // 기본 데이터 삽입\n        await this.insertDefaultData();\n    }\n    /**\n     * 테이블 생성\n     */\n    async createTables() {\n        const tables = [\n            // 타이핑 세션 테이블\n            `CREATE TABLE IF NOT EXISTS typing_sessions (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                session_id TEXT UNIQUE NOT NULL,\n                start_time INTEGER NOT NULL,\n                end_time INTEGER,\n                total_keys INTEGER DEFAULT 0,\n                duration INTEGER DEFAULT 0,\n                average_interval REAL DEFAULT 0,\n                created_at INTEGER DEFAULT (strftime('%s', 'now'))\n            )`,\n            // 타이핑 이벤트 테이블\n            `CREATE TABLE IF NOT EXISTS typing_events (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                session_id TEXT NOT NULL,\n                timestamp INTEGER NOT NULL,\n                key_count INTEGER NOT NULL,\n                interval_ms INTEGER DEFAULT 0,\n                is_active BOOLEAN DEFAULT 1,\n                created_at INTEGER DEFAULT (strftime('%s', 'now')),\n                FOREIGN KEY (session_id) REFERENCES typing_sessions(session_id)\n            )`,\n            // 일별 통계 테이블\n            `CREATE TABLE IF NOT EXISTS daily_stats (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                date TEXT UNIQUE NOT NULL,\n                total_keys INTEGER DEFAULT 0,\n                total_sessions INTEGER DEFAULT 0,\n                total_duration INTEGER DEFAULT 0,\n                average_speed REAL DEFAULT 0,\n                peak_hour INTEGER DEFAULT 0,\n                created_at INTEGER DEFAULT (strftime('%s', 'now')),\n                updated_at INTEGER DEFAULT (strftime('%s', 'now'))\n            )`,\n            // 시간별 통계 테이블\n            `CREATE TABLE IF NOT EXISTS hourly_stats (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                date TEXT NOT NULL,\n                hour INTEGER NOT NULL,\n                key_count INTEGER DEFAULT 0,\n                session_count INTEGER DEFAULT 0,\n                duration INTEGER DEFAULT 0,\n                created_at INTEGER DEFAULT (strftime('%s', 'now')),\n                updated_at INTEGER DEFAULT (strftime('%s', 'now')),\n                UNIQUE(date, hour)\n            )`,\n            // 앱 설정 테이블\n            `CREATE TABLE IF NOT EXISTS app_settings (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                key TEXT UNIQUE NOT NULL,\n                value TEXT,\n                type TEXT DEFAULT 'string',\n                description TEXT,\n                created_at INTEGER DEFAULT (strftime('%s', 'now')),\n                updated_at INTEGER DEFAULT (strftime('%s', 'now'))\n            )`,\n            // Hammy 커스터마이징 테이블\n            `CREATE TABLE IF NOT EXISTS hammy_customization (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                user_id TEXT DEFAULT 'default',\n                color_scheme TEXT DEFAULT 'default',\n                accessories TEXT,\n                position_x INTEGER DEFAULT 100,\n                position_y INTEGER DEFAULT 100,\n                size_scale REAL DEFAULT 1.0,\n                animation_speed REAL DEFAULT 1.0,\n                created_at INTEGER DEFAULT (strftime('%s', 'now')),\n                updated_at INTEGER DEFAULT (strftime('%s', 'now'))\n            )`\n        ];\n        for (const tableSQL of tables) {\n            await this.run(tableSQL);\n        }\n        console.log('Database tables created successfully');\n    }\n    /**\n     * 인덱스 생성\n     */\n    async createIndexes() {\n        const indexes = [\n            'CREATE INDEX IF NOT EXISTS idx_typing_events_session_id ON typing_events(session_id)',\n            'CREATE INDEX IF NOT EXISTS idx_typing_events_timestamp ON typing_events(timestamp)',\n            'CREATE INDEX IF NOT EXISTS idx_typing_sessions_start_time ON typing_sessions(start_time)',\n            'CREATE INDEX IF NOT EXISTS idx_daily_stats_date ON daily_stats(date)',\n            'CREATE INDEX IF NOT EXISTS idx_hourly_stats_date_hour ON hourly_stats(date, hour)'\n        ];\n        for (const indexSQL of indexes) {\n            await this.run(indexSQL);\n        }\n        console.log('Database indexes created successfully');\n    }\n    /**\n     * 기본 데이터 삽입\n     */\n    async insertDefaultData() {\n        // 기본 설정이 이미 있는지 확인\n        const existingSettings = await this.get('SELECT COUNT(*) as count FROM app_settings');\n        if (existingSettings.count === 0) {\n            const defaultSettings = [\n                ['auto_start', 'false', 'boolean', '시스템 시작 시 자동 실행'],\n                ['notifications_enabled', 'true', 'boolean', '알림 활성화'],\n                ['sound_enabled', 'true', 'boolean', '사운드 활성화'],\n                ['theme', 'light', 'string', '앱 테마 (light/dark)'],\n                ['typing_timeout', '2000', 'number', '타이핑 세션 타임아웃 (ms)'],\n                ['widget_always_on_top', 'true', 'boolean', '위젯 항상 위에 표시'],\n                ['data_retention_days', '365', 'number', '데이터 보관 기간 (일)']\n            ];\n            for (const [key, value, type, description] of defaultSettings) {\n                await this.run('INSERT INTO app_settings (key, value, type, description) VALUES (?, ?, ?, ?)', [key, value, type, description]);\n            }\n        }\n        // 기본 Hammy 커스터마이징이 있는지 확인\n        const existingCustomization = await this.get('SELECT COUNT(*) as count FROM hammy_customization');\n        if (existingCustomization.count === 0) {\n            await this.run('INSERT INTO hammy_customization (user_id, color_scheme, accessories, position_x, position_y) VALUES (?, ?, ?, ?, ?)', ['default', 'orange', '[]', 100, 100]);\n        }\n        console.log('Default data inserted successfully');\n    }\n    /**\n     * SQL 실행 (Promise 래퍼)\n     */\n    run(sql, params = []) {\n        return new Promise((resolve, reject) => {\n            if (!this.db) {\n                reject(new Error('Database not connected'));\n                return;\n            }\n            this.db.run(sql, params, function (err) {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(this);\n                }\n            });\n        });\n    }\n    /**\n     * 단일 행 조회\n     */\n    get(sql, params = []) {\n        return new Promise((resolve, reject) => {\n            if (!this.db) {\n                reject(new Error('Database not connected'));\n                return;\n            }\n            this.db.get(sql, params, (err, row) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(row);\n                }\n            });\n        });\n    }\n    /**\n     * 다중 행 조회\n     */\n    all(sql, params = []) {\n        return new Promise((resolve, reject) => {\n            if (!this.db) {\n                reject(new Error('Database not connected'));\n                return;\n            }\n            this.db.all(sql, params, (err, rows) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(rows || []);\n                }\n            });\n        });\n    }\n    /**\n     * 트랜잭션 실행\n     */\n    async transaction(operations) {\n        await this.run('BEGIN TRANSACTION');\n        try {\n            await operations();\n            await this.run('COMMIT');\n        }\n        catch (error) {\n            await this.run('ROLLBACK');\n            throw error;\n        }\n    }\n    /**\n     * 데이터베이스 연결 종료\n     */\n    close() {\n        return new Promise((resolve, reject) => {\n            if (!this.db) {\n                resolve();\n                return;\n            }\n            this.db.close((err) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    console.log('Database connection closed');\n                    this.db = null;\n                    this.isInitialized = false;\n                    resolve();\n                }\n            });\n        });\n    }\n    /**\n     * 데이터베이스 연결 상태 확인\n     */\n    isConnected() {\n        return this.db !== null && this.isInitialized;\n    }\n    /**\n     * 데이터베이스 파일 경로 반환\n     */\n    getDatabasePath() {\n        return this.dbPath;\n    }\n}\n// 싱글톤 인스턴스\nconst databaseService = new DatabaseService();\n\n\n//# sourceURL=webpack://typster-hammy/./src/main/services/database/DatabaseService.ts?\n}");

/***/ }),

/***/ "./src/main/services/database/models/AppSettings.ts":
/*!**********************************************************!*\
  !*** ./src/main/services/database/models/AppSettings.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AppSettings: () => (/* binding */ AppSettings)\n/* harmony export */ });\n/* harmony import */ var _DatabaseService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DatabaseService */ \"./src/main/services/database/DatabaseService.ts\");\n\nclass AppSettings {\n    /**\n     * 설정 값 조회\n     */\n    static async get(key) {\n        const row = await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.get('SELECT * FROM app_settings WHERE key = ?', [key]);\n        if (!row) {\n            return null;\n        }\n        return this.parseValue(row.value, row.type);\n    }\n    /**\n     * 설정 값 설정\n     */\n    static async set(key, value, type, description) {\n        const inferredType = type || this.inferType(value);\n        const stringValue = this.stringifyValue(value, inferredType);\n        const existing = await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.get('SELECT id FROM app_settings WHERE key = ?', [key]);\n        if (existing) {\n            await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.run(`UPDATE app_settings \n                 SET value = ?, type = ?, description = COALESCE(?, description), updated_at = strftime('%s', 'now')\n                 WHERE key = ?`, [stringValue, inferredType, description, key]);\n        }\n        else {\n            await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.run(`INSERT INTO app_settings (key, value, type, description)\n                 VALUES (?, ?, ?, ?)`, [key, stringValue, inferredType, description || '']);\n        }\n    }\n    /**\n     * 여러 설정 값 한번에 조회\n     */\n    static async getMultiple(keys) {\n        if (keys.length === 0) {\n            return {};\n        }\n        const placeholders = keys.map(() => '?').join(',');\n        const rows = await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.all(`SELECT key, value, type FROM app_settings WHERE key IN (${placeholders})`, keys);\n        const result = {};\n        for (const row of rows) {\n            result[row.key] = this.parseValue(row.value, row.type);\n        }\n        return result;\n    }\n    /**\n     * 여러 설정 값 한번에 설정\n     */\n    static async setMultiple(settings) {\n        await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.transaction(async () => {\n            for (const [key, value] of Object.entries(settings)) {\n                await this.set(key, value);\n            }\n        });\n    }\n    /**\n     * 모든 설정 조회\n     */\n    static async getAll() {\n        const rows = await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.all('SELECT key, value, type FROM app_settings ORDER BY key');\n        const result = {};\n        for (const row of rows) {\n            result[row.key] = this.parseValue(row.value, row.type);\n        }\n        return result;\n    }\n    /**\n     * 설정 존재 여부 확인\n     */\n    static async exists(key) {\n        const row = await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.get('SELECT 1 FROM app_settings WHERE key = ?', [key]);\n        return !!row;\n    }\n    /**\n     * 설정 삭제\n     */\n    static async delete(key) {\n        const result = await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.run('DELETE FROM app_settings WHERE key = ?', [key]);\n        return (result.changes || 0) > 0;\n    }\n    /**\n     * 설정 초기화 (기본값으로 복원)\n     */\n    static async reset() {\n        await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.run('DELETE FROM app_settings');\n        // 기본 설정 다시 삽입\n        const defaultSettings = [\n            ['auto_start', 'false', 'boolean', '시스템 시작 시 자동 실행'],\n            ['notifications_enabled', 'true', 'boolean', '알림 활성화'],\n            ['sound_enabled', 'true', 'boolean', '사운드 활성화'],\n            ['theme', 'light', 'string', '앱 테마 (light/dark)'],\n            ['typing_timeout', '2000', 'number', '타이핑 세션 타임아웃 (ms)'],\n            ['widget_always_on_top', 'true', 'boolean', '위젯 항상 위에 표시'],\n            ['data_retention_days', '365', 'number', '데이터 보관 기간 (일)']\n        ];\n        for (const [key, value, type, description] of defaultSettings) {\n            await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.run('INSERT INTO app_settings (key, value, type, description) VALUES (?, ?, ?, ?)', [key, value, type, description]);\n        }\n    }\n    /**\n     * 특정 접두사를 가진 설정들 조회\n     */\n    static async getByPrefix(prefix) {\n        const rows = await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.all('SELECT key, value, type FROM app_settings WHERE key LIKE ? ORDER BY key', [`${prefix}%`]);\n        const result = {};\n        for (const row of rows) {\n            result[row.key] = this.parseValue(row.value, row.type);\n        }\n        return result;\n    }\n    /**\n     * 설정 메타데이터 조회 (타입, 설명 포함)\n     */\n    static async getMetadata(key) {\n        const row = await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.get('SELECT * FROM app_settings WHERE key = ?', [key]);\n        return row || null;\n    }\n    /**\n     * 모든 설정 메타데이터 조회\n     */\n    static async getAllMetadata() {\n        const rows = await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.all('SELECT * FROM app_settings ORDER BY key');\n        return rows;\n    }\n    /**\n     * 값의 타입 추론\n     */\n    static inferType(value) {\n        if (typeof value === 'boolean') {\n            return 'boolean';\n        }\n        else if (typeof value === 'number') {\n            return 'number';\n        }\n        else if (typeof value === 'object' && value !== null) {\n            return 'json';\n        }\n        else {\n            return 'string';\n        }\n    }\n    /**\n     * 값을 문자열로 변환\n     */\n    static stringifyValue(value, type) {\n        switch (type) {\n            case 'boolean':\n                return value ? 'true' : 'false';\n            case 'number':\n                return value.toString();\n            case 'json':\n                return JSON.stringify(value);\n            default:\n                return String(value);\n        }\n    }\n    /**\n     * 문자열 값을 원래 타입으로 파싱\n     */\n    static parseValue(value, type) {\n        switch (type) {\n            case 'boolean':\n                return value === 'true';\n            case 'number':\n                return parseFloat(value);\n            case 'json':\n                try {\n                    return JSON.parse(value);\n                }\n                catch {\n                    return null;\n                }\n            default:\n                return value;\n        }\n    }\n    // 편의 메서드들\n    static async getString(key, defaultValue = '') {\n        const value = await this.get(key);\n        return value !== null ? value : defaultValue;\n    }\n    static async getNumber(key, defaultValue = 0) {\n        const value = await this.get(key);\n        return value !== null ? value : defaultValue;\n    }\n    static async getBoolean(key, defaultValue = false) {\n        const value = await this.get(key);\n        return value !== null ? value : defaultValue;\n    }\n    static async getJSON(key, defaultValue = null) {\n        const value = await this.get(key);\n        return value !== null ? value : defaultValue;\n    }\n}\n\n\n//# sourceURL=webpack://typster-hammy/./src/main/services/database/models/AppSettings.ts?\n}");

/***/ }),

/***/ "./src/main/services/database/models/DailyStats.ts":
/*!*********************************************************!*\
  !*** ./src/main/services/database/models/DailyStats.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DailyStats: () => (/* binding */ DailyStats)\n/* harmony export */ });\n/* harmony import */ var _DatabaseService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DatabaseService */ \"./src/main/services/database/DatabaseService.ts\");\n/* harmony import */ var _TypingSession__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TypingSession */ \"./src/main/services/database/models/TypingSession.ts\");\n/* harmony import */ var _TypingEvent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TypingEvent */ \"./src/main/services/database/models/TypingEvent.ts\");\n\n\n\nclass DailyStats {\n    /**\n     * 일별 통계 생성 또는 업데이트\n     */\n    static async createOrUpdate(statsData) {\n        const existing = await this.findByDate(statsData.date);\n        if (existing) {\n            await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.run(`UPDATE daily_stats \n                 SET total_keys = ?, total_sessions = ?, total_duration = ?, \n                     average_speed = ?, peak_hour = ?, updated_at = strftime('%s', 'now')\n                 WHERE date = ?`, [\n                statsData.total_keys,\n                statsData.total_sessions,\n                statsData.total_duration,\n                statsData.average_speed,\n                statsData.peak_hour,\n                statsData.date\n            ]);\n        }\n        else {\n            await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.run(`INSERT INTO daily_stats (date, total_keys, total_sessions, total_duration, average_speed, peak_hour)\n                 VALUES (?, ?, ?, ?, ?, ?)`, [\n                statsData.date,\n                statsData.total_keys,\n                statsData.total_sessions,\n                statsData.total_duration,\n                statsData.average_speed,\n                statsData.peak_hour\n            ]);\n        }\n    }\n    /**\n     * 날짜로 일별 통계 조회\n     */\n    static async findByDate(date) {\n        const row = await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.get('SELECT * FROM daily_stats WHERE date = ?', [date]);\n        return row || null;\n    }\n    /**\n     * 날짜 범위로 일별 통계 조회\n     */\n    static async findByDateRange(startDate, endDate) {\n        const rows = await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.all('SELECT * FROM daily_stats WHERE date >= ? AND date <= ? ORDER BY date ASC', [startDate, endDate]);\n        return rows;\n    }\n    /**\n     * 최근 N일 통계 조회\n     */\n    static async findRecent(days = 30) {\n        const rows = await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.all('SELECT * FROM daily_stats ORDER BY date DESC LIMIT ?', [days]);\n        return rows.reverse(); // 날짜 순으로 정렬\n    }\n    /**\n     * 특정 날짜의 통계를 실시간으로 계산하여 업데이트\n     */\n    static async calculateAndUpdateStats(date) {\n        const sessions = await _TypingSession__WEBPACK_IMPORTED_MODULE_1__.TypingSession.findByDate(date);\n        const events = await _TypingEvent__WEBPACK_IMPORTED_MODULE_2__.TypingEvent.findByDate(date);\n        // 기본 통계 계산\n        const totalSessions = sessions.length;\n        const totalKeys = sessions.reduce((sum, session) => sum + session.total_keys, 0);\n        const totalDuration = sessions.reduce((sum, session) => sum + session.duration, 0);\n        // 평균 타이핑 속도 계산 (분당 키 입력 수)\n        const averageSpeed = totalDuration > 0\n            ? (totalKeys / (totalDuration / 1000)) * 60\n            : 0;\n        // 가장 활발한 시간대 계산\n        const hourlyActivity = await _TypingEvent__WEBPACK_IMPORTED_MODULE_2__.TypingEvent.getHourlyActivity(date);\n        const peakHour = hourlyActivity.reduce((maxHour, current) => current.eventCount > maxHour.eventCount ? current : maxHour).hour;\n        const statsData = {\n            date,\n            total_keys: totalKeys,\n            total_sessions: totalSessions,\n            total_duration: totalDuration,\n            average_speed: Math.round(averageSpeed * 100) / 100,\n            peak_hour: peakHour\n        };\n        await this.createOrUpdate(statsData);\n        return await this.findByDate(date);\n    }\n    /**\n     * 주간 통계 계산\n     */\n    static async getWeeklyStats(startDate) {\n        // 시작 날짜부터 7일간의 통계\n        const endDate = new Date(new Date(startDate).getTime() + 6 * 24 * 60 * 60 * 1000)\n            .toISOString().split('T')[0];\n        const dailyStats = await this.findByDateRange(startDate, endDate);\n        const totalKeys = dailyStats.reduce((sum, day) => sum + day.total_keys, 0);\n        const totalSessions = dailyStats.reduce((sum, day) => sum + day.total_sessions, 0);\n        const totalDuration = dailyStats.reduce((sum, day) => sum + day.total_duration, 0);\n        const averageSpeed = dailyStats.length > 0\n            ? dailyStats.reduce((sum, day) => sum + day.average_speed, 0) / dailyStats.length\n            : 0;\n        return {\n            totalKeys,\n            totalSessions,\n            totalDuration,\n            averageSpeed: Math.round(averageSpeed * 100) / 100,\n            dailyStats\n        };\n    }\n    /**\n     * 월간 통계 계산\n     */\n    static async getMonthlyStats(year, month) {\n        const startDate = `${year}-${month.toString().padStart(2, '0')}-01`;\n        const endDate = new Date(year, month, 0).toISOString().split('T')[0]; // 해당 월의 마지막 날\n        const dailyStats = await this.findByDateRange(startDate, endDate);\n        const totalKeys = dailyStats.reduce((sum, day) => sum + day.total_keys, 0);\n        const totalSessions = dailyStats.reduce((sum, day) => sum + day.total_sessions, 0);\n        const totalDuration = dailyStats.reduce((sum, day) => sum + day.total_duration, 0);\n        const averageSpeed = dailyStats.length > 0\n            ? dailyStats.reduce((sum, day) => sum + day.average_speed, 0) / dailyStats.length\n            : 0;\n        // 가장 활발했던 날 찾기\n        const peakDay = dailyStats.reduce((maxDay, current) => current.total_keys > maxDay.total_keys ? current : maxDay, { total_keys: 0, date: startDate }).date;\n        return {\n            totalKeys,\n            totalSessions,\n            totalDuration,\n            averageSpeed: Math.round(averageSpeed * 100) / 100,\n            dailyStats,\n            peakDay\n        };\n    }\n    /**\n     * 타이핑 트렌드 분석 (최근 30일)\n     */\n    static async getTypingTrend() {\n        const recentStats = await this.findRecent(30);\n        if (recentStats.length < 7) {\n            return {\n                trend: 'stable',\n                changePercentage: 0,\n                recentStats\n            };\n        }\n        // 첫 주와 마지막 주 평균 비교\n        const firstWeekAvg = recentStats.slice(0, 7)\n            .reduce((sum, day) => sum + day.total_keys, 0) / 7;\n        const lastWeekAvg = recentStats.slice(-7)\n            .reduce((sum, day) => sum + day.total_keys, 0) / 7;\n        const changePercentage = firstWeekAvg > 0\n            ? ((lastWeekAvg - firstWeekAvg) / firstWeekAvg) * 100\n            : 0;\n        let trend = 'stable';\n        if (Math.abs(changePercentage) > 10) {\n            trend = changePercentage > 0 ? 'increasing' : 'decreasing';\n        }\n        return {\n            trend,\n            changePercentage: Math.round(changePercentage * 100) / 100,\n            recentStats\n        };\n    }\n    /**\n     * 오늘 통계 실시간 업데이트\n     */\n    static async updateTodayStats() {\n        const today = new Date().toISOString().split('T')[0];\n        return await this.calculateAndUpdateStats(today);\n    }\n    /**\n     * 오래된 통계 삭제\n     */\n    static async deleteOldStats(daysToKeep = 365) {\n        const cutoffDate = new Date(Date.now() - daysToKeep * 24 * 60 * 60 * 1000)\n            .toISOString().split('T')[0];\n        const result = await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.run('DELETE FROM daily_stats WHERE date < ?', [cutoffDate]);\n        return result.changes || 0;\n    }\n    /**\n     * 전체 통계 수 조회\n     */\n    static async getTotalCount() {\n        const row = await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.get('SELECT COUNT(*) as count FROM daily_stats');\n        return row.count || 0;\n    }\n    /**\n     * 통계 삭제\n     */\n    static async deleteByDate(date) {\n        const result = await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.run('DELETE FROM daily_stats WHERE date = ?', [date]);\n        return (result.changes || 0) > 0;\n    }\n}\n\n\n//# sourceURL=webpack://typster-hammy/./src/main/services/database/models/DailyStats.ts?\n}");

/***/ }),

/***/ "./src/main/services/database/models/TypingEvent.ts":
/*!**********************************************************!*\
  !*** ./src/main/services/database/models/TypingEvent.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TypingEvent: () => (/* binding */ TypingEvent)\n/* harmony export */ });\n/* harmony import */ var _DatabaseService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DatabaseService */ \"./src/main/services/database/DatabaseService.ts\");\n\nclass TypingEvent {\n    /**\n     * 새로운 타이핑 이벤트 생성\n     */\n    static async create(eventData) {\n        const result = await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.run(`INSERT INTO typing_events (session_id, timestamp, key_count, interval_ms, is_active)\n             VALUES (?, ?, ?, ?, ?)`, [\n            eventData.session_id,\n            eventData.timestamp,\n            eventData.key_count,\n            eventData.interval_ms,\n            eventData.is_active ? 1 : 0\n        ]);\n        return result.lastID;\n    }\n    /**\n     * 세션 ID로 타이핑 이벤트 조회\n     */\n    static async findBySessionId(sessionId) {\n        const rows = await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.all('SELECT * FROM typing_events WHERE session_id = ? ORDER BY timestamp ASC', [sessionId]);\n        return rows.map(row => ({\n            ...row,\n            is_active: Boolean(row.is_active)\n        }));\n    }\n    /**\n     * 날짜 범위로 타이핑 이벤트 조회\n     */\n    static async findByDateRange(startDate, endDate) {\n        const rows = await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.all(`SELECT * FROM typing_events \n             WHERE timestamp >= ? AND timestamp <= ?\n             ORDER BY timestamp ASC`, [startDate, endDate]);\n        return rows.map(row => ({\n            ...row,\n            is_active: Boolean(row.is_active)\n        }));\n    }\n    /**\n     * 특정 날짜의 타이핑 이벤트 조회\n     */\n    static async findByDate(date) {\n        // date는 'YYYY-MM-DD' 형식\n        const startOfDay = new Date(date + 'T00:00:00').getTime();\n        const endOfDay = new Date(date + 'T23:59:59').getTime();\n        return this.findByDateRange(startOfDay, endOfDay);\n    }\n    /**\n     * 최근 N개 이벤트 조회\n     */\n    static async findRecent(limit = 100) {\n        const rows = await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.all('SELECT * FROM typing_events ORDER BY timestamp DESC LIMIT ?', [limit]);\n        return rows.map(row => ({\n            ...row,\n            is_active: Boolean(row.is_active)\n        }));\n    }\n    /**\n     * 세션의 타이핑 패턴 분석\n     */\n    static async analyzeSessionPattern(sessionId) {\n        const events = await this.findBySessionId(sessionId);\n        if (events.length === 0) {\n            return {\n                totalEvents: 0,\n                averageInterval: 0,\n                minInterval: 0,\n                maxInterval: 0,\n                burstPeriods: 0,\n                pausePeriods: 0\n            };\n        }\n        const intervals = events\n            .filter(event => event.interval_ms > 0)\n            .map(event => event.interval_ms);\n        if (intervals.length === 0) {\n            return {\n                totalEvents: events.length,\n                averageInterval: 0,\n                minInterval: 0,\n                maxInterval: 0,\n                burstPeriods: 0,\n                pausePeriods: 0\n            };\n        }\n        const averageInterval = intervals.reduce((sum, interval) => sum + interval, 0) / intervals.length;\n        const minInterval = Math.min(...intervals);\n        const maxInterval = Math.max(...intervals);\n        const burstPeriods = intervals.filter(interval => interval < 100).length;\n        const pausePeriods = intervals.filter(interval => interval > 2000).length;\n        return {\n            totalEvents: events.length,\n            averageInterval: Math.round(averageInterval * 100) / 100,\n            minInterval,\n            maxInterval,\n            burstPeriods,\n            pausePeriods\n        };\n    }\n    /**\n     * 시간대별 타이핑 활동 분석\n     */\n    static async getHourlyActivity(date) {\n        const startOfDay = new Date(date + 'T00:00:00').getTime();\n        const endOfDay = new Date(date + 'T23:59:59').getTime();\n        const rows = await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.all(`SELECT \n                strftime('%H', datetime(timestamp/1000, 'unixepoch', 'localtime')) as hour,\n                COUNT(*) as event_count\n             FROM typing_events \n             WHERE timestamp >= ? AND timestamp <= ?\n             GROUP BY hour\n             ORDER BY hour`, [startOfDay, endOfDay]);\n        // 0-23시까지 모든 시간대 포함 (데이터가 없는 시간대는 0으로)\n        const hourlyData = [];\n        for (let hour = 0; hour < 24; hour++) {\n            const found = rows.find(row => parseInt(row.hour) === hour);\n            hourlyData.push({\n                hour,\n                eventCount: found ? found.event_count : 0\n            });\n        }\n        return hourlyData;\n    }\n    /**\n     * 타이핑 속도 계산 (분당 키 입력 수)\n     */\n    static async calculateTypingSpeed(sessionId) {\n        const events = await this.findBySessionId(sessionId);\n        if (events.length < 2) {\n            return 0;\n        }\n        const firstEvent = events[0];\n        const lastEvent = events[events.length - 1];\n        const durationMinutes = (lastEvent.timestamp - firstEvent.timestamp) / (1000 * 60);\n        if (durationMinutes === 0) {\n            return 0;\n        }\n        const keysPerMinute = events.length / durationMinutes;\n        return Math.round(keysPerMinute * 100) / 100;\n    }\n    /**\n     * 배치로 여러 이벤트 생성 (성능 최적화)\n     */\n    static async createBatch(events) {\n        if (events.length === 0)\n            return;\n        await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.transaction(async () => {\n            for (const event of events) {\n                await this.create(event);\n            }\n        });\n    }\n    /**\n     * 오래된 이벤트 삭제 (데이터 정리)\n     */\n    static async deleteOldEvents(daysToKeep = 365) {\n        const cutoffTime = Date.now() - (daysToKeep * 24 * 60 * 60 * 1000);\n        const result = await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.run('DELETE FROM typing_events WHERE timestamp < ?', [cutoffTime]);\n        return result.changes || 0;\n    }\n    /**\n     * 세션의 모든 이벤트 삭제\n     */\n    static async deleteBySessionId(sessionId) {\n        const result = await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.run('DELETE FROM typing_events WHERE session_id = ?', [sessionId]);\n        return result.changes || 0;\n    }\n    /**\n     * 전체 이벤트 수 조회\n     */\n    static async getTotalCount() {\n        const row = await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.get('SELECT COUNT(*) as count FROM typing_events');\n        return row.count || 0;\n    }\n    /**\n     * 세션별 이벤트 수 조회\n     */\n    static async getEventCountBySession(sessionId) {\n        const row = await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.get('SELECT COUNT(*) as count FROM typing_events WHERE session_id = ?', [sessionId]);\n        return row.count || 0;\n    }\n}\n\n\n//# sourceURL=webpack://typster-hammy/./src/main/services/database/models/TypingEvent.ts?\n}");

/***/ }),

/***/ "./src/main/services/database/models/TypingSession.ts":
/*!************************************************************!*\
  !*** ./src/main/services/database/models/TypingSession.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TypingSession: () => (/* binding */ TypingSession)\n/* harmony export */ });\n/* harmony import */ var _DatabaseService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DatabaseService */ \"./src/main/services/database/DatabaseService.ts\");\n\nclass TypingSession {\n    /**\n     * 새로운 타이핑 세션 생성\n     */\n    static async create(sessionData) {\n        const result = await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.run(`INSERT INTO typing_sessions (session_id, start_time, end_time, total_keys, duration, average_interval)\n             VALUES (?, ?, ?, ?, ?, ?)`, [\n            sessionData.session_id,\n            sessionData.start_time,\n            sessionData.end_time || null,\n            sessionData.total_keys,\n            sessionData.duration,\n            sessionData.average_interval\n        ]);\n        return result.lastID;\n    }\n    /**\n     * 세션 ID로 타이핑 세션 조회\n     */\n    static async findBySessionId(sessionId) {\n        const row = await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.get('SELECT * FROM typing_sessions WHERE session_id = ?', [sessionId]);\n        return row || null;\n    }\n    /**\n     * 활성 세션 조회 (end_time이 null인 세션)\n     */\n    static async findActiveSessions() {\n        const rows = await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.all('SELECT * FROM typing_sessions WHERE end_time IS NULL ORDER BY start_time DESC');\n        return rows;\n    }\n    /**\n     * 세션 종료 처리\n     */\n    static async endSession(sessionId, endTime, totalKeys, duration, averageInterval) {\n        await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.run(`UPDATE typing_sessions \n             SET end_time = ?, total_keys = ?, duration = ?, average_interval = ?\n             WHERE session_id = ?`, [endTime, totalKeys, duration, averageInterval, sessionId]);\n    }\n    /**\n     * 날짜 범위로 세션 조회\n     */\n    static async findByDateRange(startDate, endDate) {\n        const rows = await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.all(`SELECT * FROM typing_sessions \n             WHERE start_time >= ? AND start_time <= ?\n             ORDER BY start_time DESC`, [startDate, endDate]);\n        return rows;\n    }\n    /**\n     * 특정 날짜의 세션 조회\n     */\n    static async findByDate(date) {\n        // date는 'YYYY-MM-DD' 형식\n        const startOfDay = new Date(date + 'T00:00:00').getTime();\n        const endOfDay = new Date(date + 'T23:59:59').getTime();\n        return this.findByDateRange(startOfDay, endOfDay);\n    }\n    /**\n     * 최근 N개 세션 조회\n     */\n    static async findRecent(limit = 10) {\n        const rows = await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.all('SELECT * FROM typing_sessions ORDER BY start_time DESC LIMIT ?', [limit]);\n        return rows;\n    }\n    /**\n     * 세션 통계 조회\n     */\n    static async getSessionStats(sessionId) {\n        const session = await this.findBySessionId(sessionId);\n        if (!session || !session.end_time) {\n            return null;\n        }\n        const keyRate = session.duration > 0\n            ? (session.total_keys / (session.duration / 1000)) * 60\n            : 0;\n        return {\n            totalKeys: session.total_keys,\n            duration: session.duration,\n            averageInterval: session.average_interval,\n            keyRate: Math.round(keyRate * 100) / 100\n        };\n    }\n    /**\n     * 오래된 세션 삭제 (데이터 정리)\n     */\n    static async deleteOldSessions(daysToKeep = 365) {\n        const cutoffTime = Date.now() - (daysToKeep * 24 * 60 * 60 * 1000);\n        const result = await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.run('DELETE FROM typing_sessions WHERE start_time < ?', [cutoffTime]);\n        return result.changes || 0;\n    }\n    /**\n     * 세션 삭제\n     */\n    static async delete(sessionId) {\n        const result = await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.run('DELETE FROM typing_sessions WHERE session_id = ?', [sessionId]);\n        return (result.changes || 0) > 0;\n    }\n    /**\n     * 모든 세션 수 조회\n     */\n    static async getTotalCount() {\n        const row = await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.get('SELECT COUNT(*) as count FROM typing_sessions');\n        return row.count || 0;\n    }\n    /**\n     * 세션 업데이트 (진행 중인 세션의 키 카운트 업데이트)\n     */\n    static async updateKeyCount(sessionId, totalKeys, averageInterval) {\n        await _DatabaseService__WEBPACK_IMPORTED_MODULE_0__.databaseService.run('UPDATE typing_sessions SET total_keys = ?, average_interval = ? WHERE session_id = ?', [totalKeys, averageInterval, sessionId]);\n    }\n}\n\n\n//# sourceURL=webpack://typster-hammy/./src/main/services/database/models/TypingSession.ts?\n}");

/***/ }),

/***/ "./src/main/services/native sync recursive":
/*!****************************************!*\
  !*** ./src/main/services/native/ sync ***!
  \****************************************/
/***/ ((module) => {

eval("{function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = \"./src/main/services/native sync recursive\";\nmodule.exports = webpackEmptyContext;\n\n//# sourceURL=webpack://typster-hammy/./src/main/services/native/_sync?\n}");

/***/ }),

/***/ "./src/main/services/native/index.ts":
/*!*******************************************!*\
  !*** ./src/main/services/native/index.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NativeKeyboardListener: () => (/* binding */ NativeKeyboardListener),\n/* harmony export */   nativeKeyboardListener: () => (/* binding */ nativeKeyboardListener)\n/* harmony export */ });\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);\n// 네이티브 키보드 리스너 TypeScript 진입점\n\n// 네이티브 모듈을 지연 로드하기 위한 변수\nlet nativeModule = null;\n// 네이티브 모듈 로드 함수\nfunction loadNativeModule() {\n    if (nativeModule) {\n        return nativeModule;\n    }\n    try {\n        // 직접 경로를 하드코딩해서 시도\n        const modulePath = path__WEBPACK_IMPORTED_MODULE_0__.join(process.cwd(), 'dist', 'main', 'build', 'Release', 'keyboard_native.node');\n        console.log(`Attempting to load native module from: ${modulePath}`);\n        // 파일 존재 확인\n        const fs = __webpack_require__(/*! fs */ \"fs\");\n        if (!fs.existsSync(modulePath)) {\n            throw new Error(`Native module file does not exist at: ${modulePath}`);\n        }\n        console.log('Native module file exists, attempting to load...');\n        // process.dlopen을 직접 사용해서 로드 시도\n        const Module = __webpack_require__(/*! module */ \"module\");\n        const moduleObj = { exports: {} };\n        try {\n            process.dlopen(moduleObj, modulePath);\n            nativeModule = moduleObj.exports;\n            console.log('Successfully loaded native module using process.dlopen');\n            return nativeModule;\n        }\n        catch (dlopenError) {\n            console.log('process.dlopen failed, trying require...');\n            // 백업: 일반 require 시도\n            nativeModule = __webpack_require__(\"./src/main/services/native sync recursive\")(modulePath);\n            console.log('Successfully loaded native module using require');\n            return nativeModule;\n        }\n    }\n    catch (error) {\n        console.error('Failed to load native keyboard module:', error);\n        throw new Error('Native keyboard module not found. Please run \"npm run build:native\" first.');\n    }\n}\nclass NativeKeyboardListener {\n    constructor() {\n        this.callback = null;\n    }\n    /**\n     * 키보드 리스닝 시작\n     */\n    startListening(callback) {\n        if (this.callback) {\n            throw new Error('Keyboard listener is already running');\n        }\n        this.callback = callback;\n        try {\n            const module = loadNativeModule();\n            return module.startListening((event) => {\n                if (this.callback) {\n                    this.callback(event);\n                }\n            });\n        }\n        catch (error) {\n            this.callback = null;\n            throw error;\n        }\n    }\n    /**\n     * 키보드 리스닝 중지\n     */\n    stopListening() {\n        if (!this.callback) {\n            return true; // 이미 중지됨\n        }\n        try {\n            const module = loadNativeModule();\n            const result = module.stopListening();\n            this.callback = null;\n            return result;\n        }\n        catch (error) {\n            console.error('Failed to stop keyboard listener:', error);\n            return false;\n        }\n    }\n    /**\n     * 권한 확인\n     */\n    checkPermissions() {\n        try {\n            const module = loadNativeModule();\n            return module.checkPermissions();\n        }\n        catch (error) {\n            console.error('Failed to check permissions:', error);\n            return {\n                hasPermission: false,\n                requiresElevation: true,\n                permissionMessage: 'Failed to check permissions'\n            };\n        }\n    }\n    /**\n     * 리스닝 상태 확인\n     */\n    isListening() {\n        try {\n            const module = loadNativeModule();\n            return module.isListening();\n        }\n        catch (error) {\n            return false;\n        }\n    }\n}\n// 싱글톤 인스턴스 내보내기\nconst nativeKeyboardListener = new NativeKeyboardListener();\n\n\n//# sourceURL=webpack://typster-hammy/./src/main/services/native/index.ts?\n}");

/***/ }),

/***/ "./src/main/windows/WindowManager.ts":
/*!*******************************************!*\
  !*** ./src/main/windows/WindowManager.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WindowManager: () => (/* binding */ WindowManager),\n/* harmony export */   windowManager: () => (/* binding */ windowManager)\n/* harmony export */ });\n/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! electron */ \"electron\");\n/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _services_database_DataManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../services/database/DataManager */ \"./src/main/services/database/DataManager.ts\");\n\n\n\nclass WindowManager {\n    constructor() {\n        this.mainWindow = null;\n        this.widgetWindow = null;\n        this.isDev = \"development\" === 'development';\n    }\n    /**\n     * 메인 창 생성\n     */\n    createMainWindow() {\n        const config = {\n            width: 1200,\n            height: 800,\n            show: false,\n            frame: true,\n            resizable: true,\n            alwaysOnTop: false\n        };\n        this.mainWindow = this.createWindow(config, {\n            nodeIntegration: false,\n            contextIsolation: true,\n            preload: path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname, 'preload.js')\n        });\n        // 메인 창 로드\n        if (this.isDev) {\n            this.mainWindow.loadURL('http://localhost:3001');\n            this.mainWindow.webContents.openDevTools();\n        }\n        else {\n            this.mainWindow.loadFile(path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname, '../../renderer/index.html'));\n        }\n        // 준비되면 표시\n        this.mainWindow.once('ready-to-show', () => {\n            this.mainWindow?.show();\n        });\n        // 창 닫힘 처리\n        this.mainWindow.on('closed', () => {\n            this.mainWindow = null;\n        });\n        return this.mainWindow;\n    }\n    /**\n     * 위젯 창 생성\n     */\n    async createWidgetWindow() {\n        if (this.widgetWindow) {\n            return this.widgetWindow;\n        }\n        // 저장된 위치 불러오기\n        const savedX = await _services_database_DataManager__WEBPACK_IMPORTED_MODULE_2__.dataManager.getSetting('widget_position_x');\n        const savedY = await _services_database_DataManager__WEBPACK_IMPORTED_MODULE_2__.dataManager.getSetting('widget_position_y');\n        // 기본 위치 (화면 우측 하단)\n        const primaryDisplay = electron__WEBPACK_IMPORTED_MODULE_0__.screen.getPrimaryDisplay();\n        const { width: screenWidth, height: screenHeight } = primaryDisplay.workAreaSize;\n        const defaultX = screenWidth - 140; // 위젯 너비 + 여백\n        const defaultY = screenHeight - 140; // 위젯 높이 + 여백\n        const config = {\n            width: 120,\n            height: 120,\n            x: savedX || defaultX,\n            y: savedY || defaultY,\n            alwaysOnTop: true,\n            frame: false,\n            transparent: true,\n            resizable: false,\n            skipTaskbar: true,\n            show: false\n        };\n        this.widgetWindow = this.createWindow(config, {\n            nodeIntegration: false,\n            contextIsolation: true,\n            preload: path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname, 'preload.js')\n        });\n        // 위젯 창 로드\n        if (this.isDev) {\n            this.widgetWindow.loadURL('http://localhost:3002'); // 별도 포트\n        }\n        else {\n            this.widgetWindow.loadFile(path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname, '../../renderer/widget.html'));\n        }\n        // 화면 경계 내로 위치 조정\n        this.constrainWidgetToScreen();\n        // 준비되면 표시\n        this.widgetWindow.once('ready-to-show', () => {\n            this.widgetWindow?.show();\n        });\n        // 창 닫힘 처리\n        this.widgetWindow.on('closed', () => {\n            this.widgetWindow = null;\n        });\n        // 위치 변경 시 저장\n        this.widgetWindow.on('moved', () => {\n            this.saveWidgetPosition();\n        });\n        return this.widgetWindow;\n    }\n    /**\n     * 기본 창 생성 함수\n     */\n    createWindow(config, webPreferences) {\n        return new electron__WEBPACK_IMPORTED_MODULE_0__.BrowserWindow({\n            width: config.width,\n            height: config.height,\n            x: config.x,\n            y: config.y,\n            alwaysOnTop: config.alwaysOnTop || false,\n            frame: config.frame !== false,\n            transparent: config.transparent || false,\n            resizable: config.resizable !== false,\n            skipTaskbar: config.skipTaskbar || false,\n            show: config.show !== false,\n            webPreferences,\n            title: 'Typster Hammy'\n        });\n    }\n    /**\n     * 위젯을 화면 경계 내로 제한\n     */\n    constrainWidgetToScreen() {\n        if (!this.widgetWindow)\n            return;\n        const [x, y] = this.widgetWindow.getPosition();\n        const [width, height] = this.widgetWindow.getSize();\n        const primaryDisplay = electron__WEBPACK_IMPORTED_MODULE_0__.screen.getPrimaryDisplay();\n        const { width: screenWidth, height: screenHeight } = primaryDisplay.workAreaSize;\n        const constrainedX = Math.max(0, Math.min(x, screenWidth - width));\n        const constrainedY = Math.max(0, Math.min(y, screenHeight - height));\n        if (x !== constrainedX || y !== constrainedY) {\n            this.widgetWindow.setPosition(constrainedX, constrainedY);\n        }\n    }\n    /**\n     * 위젯 위치 저장\n     */\n    async saveWidgetPosition() {\n        if (!this.widgetWindow)\n            return;\n        try {\n            const [x, y] = this.widgetWindow.getPosition();\n            await _services_database_DataManager__WEBPACK_IMPORTED_MODULE_2__.dataManager.setSetting('widget_position_x', x);\n            await _services_database_DataManager__WEBPACK_IMPORTED_MODULE_2__.dataManager.setSetting('widget_position_y', y);\n        }\n        catch (error) {\n            console.error('Failed to save widget position:', error);\n        }\n    }\n    /**\n     * 위젯 표시/숨김\n     */\n    showWidget() {\n        if (this.widgetWindow) {\n            this.widgetWindow.show();\n        }\n    }\n    hideWidget() {\n        if (this.widgetWindow) {\n            this.widgetWindow.hide();\n        }\n    }\n    toggleWidget() {\n        if (this.widgetWindow) {\n            if (this.widgetWindow.isVisible()) {\n                this.hideWidget();\n            }\n            else {\n                this.showWidget();\n            }\n        }\n    }\n    /**\n     * 위젯 위치 설정\n     */\n    setWidgetPosition(x, y) {\n        if (!this.widgetWindow)\n            return;\n        // 화면 경계 확인\n        const [width, height] = this.widgetWindow.getSize();\n        const primaryDisplay = electron__WEBPACK_IMPORTED_MODULE_0__.screen.getPrimaryDisplay();\n        const { width: screenWidth, height: screenHeight } = primaryDisplay.workAreaSize;\n        const constrainedX = Math.max(0, Math.min(x, screenWidth - width));\n        const constrainedY = Math.max(0, Math.min(y, screenHeight - height));\n        this.widgetWindow.setPosition(constrainedX, constrainedY);\n    }\n    /**\n     * 위젯 위치 가져오기\n     */\n    getWidgetPosition() {\n        if (!this.widgetWindow)\n            return null;\n        const [x, y] = this.widgetWindow.getPosition();\n        return { x, y };\n    }\n    /**\n     * 창 상태 확인\n     */\n    isMainWindowOpen() {\n        return this.mainWindow !== null && !this.mainWindow.isDestroyed();\n    }\n    isWidgetWindowOpen() {\n        return this.widgetWindow !== null && !this.widgetWindow.isDestroyed();\n    }\n    isWidgetVisible() {\n        return this.isWidgetWindowOpen() && this.widgetWindow.isVisible();\n    }\n    /**\n     * 창 참조 가져오기\n     */\n    getMainWindow() {\n        return this.mainWindow;\n    }\n    getWidgetWindow() {\n        return this.widgetWindow;\n    }\n    /**\n     * 모든 창 닫기\n     */\n    closeAllWindows() {\n        if (this.widgetWindow && !this.widgetWindow.isDestroyed()) {\n            this.widgetWindow.close();\n        }\n        if (this.mainWindow && !this.mainWindow.isDestroyed()) {\n            this.mainWindow.close();\n        }\n    }\n    /**\n     * 리소스 정리\n     */\n    destroy() {\n        this.closeAllWindows();\n        this.mainWindow = null;\n        this.widgetWindow = null;\n    }\n}\n// 싱글톤 인스턴스\nconst windowManager = new WindowManager();\n\n\n//# sourceURL=webpack://typster-hammy/./src/main/windows/WindowManager.ts?\n}");

/***/ }),

/***/ "./src/shared/types.ts":
/*!*****************************!*\
  !*** ./src/shared/types.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IPCChannels: () => (/* binding */ IPCChannels)\n/* harmony export */ });\n// Shared types between main and renderer processes\nvar IPCChannels;\n(function (IPCChannels) {\n    IPCChannels[\"TYPING_EVENT\"] = \"typing-event\";\n    IPCChannels[\"TYPING_SESSION_END\"] = \"typing-session-end\";\n    IPCChannels[\"HAMMY_REACTION\"] = \"hammy-reaction\";\n    IPCChannels[\"DASHBOARD_OPEN\"] = \"dashboard-open\";\n    IPCChannels[\"DASHBOARD_CLOSE\"] = \"dashboard-close\";\n    IPCChannels[\"STATISTICS_REQUEST\"] = \"statistics-request\";\n    IPCChannels[\"STATISTICS_RESPONSE\"] = \"statistics-response\";\n    IPCChannels[\"SETTINGS_UPDATE\"] = \"settings-update\";\n    IPCChannels[\"PING\"] = \"ping\";\n    IPCChannels[\"PONG\"] = \"pong\";\n})(IPCChannels || (IPCChannels = {}));\n\n\n//# sourceURL=webpack://typster-hammy/./src/shared/types.ts?\n}");

/***/ }),

/***/ "electron":
/*!***************************!*\
  !*** external "electron" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("electron");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "module":
/*!*************************!*\
  !*** external "module" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("module");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "sqlite3":
/*!**************************!*\
  !*** external "sqlite3" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("sqlite3");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main/main.ts");
/******/ 	
/******/ })()
;